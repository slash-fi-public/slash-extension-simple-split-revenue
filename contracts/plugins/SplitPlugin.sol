//SPDX-License-Identifier: MIT

pragma solidity ^0.8.4;

import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";

import "./interfaces/ISlashSplitPlugin.sol";
import "../libs/UniversalERC20.sol";

/**
 * @notice Split plugin contract
 */
contract SplitPlugin is OwnableUpgradeable {
    using UniversalERC20 for IERC20Upgradeable;

    uint8 public constant MAX_SPLITS = 10;
    uint16 public constant RATE_PRECISION = 10000;

    address private _merchantWallet;
    address private _merchantContract;
    // Array of wallet to receive payment
    address[] private _splitWallets;
    // Rates for the split wallets
    mapping(address => uint16) private _splitRates;

    event PaymentSplitted(
        address indexed account,
        address indexed token,
        uint256 amount,
        uint16 rate
    );

    modifier validatePermission() {
        require(
            owner() == _msgSender() || _merchantWallet == _msgSender(),
            "Unpermitted"
        );
        _;
    }

    /**
     * @notice Initialize plugin
     */
    function initialize(address merchantWallet_, address merchantContract_)
        public
        initializer
    {
        __Ownable_init();

        _merchantWallet = merchantWallet_;
        _merchantContract = merchantContract_;
    }

    /**
     * @notice Configure split wallets and rates
     */
    function configureSplitsData(
        address[] memory splitWallets_,
        uint16[] memory splitRates_
    ) external validatePermission {
        require(splitWallets_.length == splitRates_.length, "Invalid params");

        uint256 splitCount = splitWallets_.length;
        require(
            splitCount > 0 && splitCount <= MAX_SPLITS,
            "Invalid split count"
        );

        delete _splitWallets; // Clear split wallets
        uint32 totalRates;
        for (uint256 i = 0; i < splitCount; i++) {
            require(splitWallets_[i] != address(0), "Invalid split wallet");
            _splitWallets.push(splitWallets_[i]);
            _splitRates[splitWallets_[i]] = splitRates_[i];
            totalRates += splitRates_[i];
        }
        // Sum of rates must be 100% (RATE_PRECISION)
        require(totalRates == RATE_PRECISION, "Invalid split rates");
    }

    /**
     * @notice Update merchant wallet
     * @dev Slash owner or merchant owner can update merchant wallet
     */
    function updateMerchantWallet(address merchantWallet_)
        external
        validatePermission
    {
        require(merchantWallet_ != address(0), "Invalid merchant wallet");

        _merchantWallet = merchantWallet_;
    }

    function viewMerchantWallet() external view returns (address) {
        return _merchantWallet;
    }

    /**
     * @notice Change merchant contract. This is only for displaying purpose.
     * Allocating merchant contract and plugin contract should be done in the merchant contract
     * @dev Only slash owner can change the merchant contract
     */
    function updateMerchantContract(address merchantContract_)
        external
        onlyOwner
    {
        _merchantContract = merchantContract_;
    }

    function viewMerchantContract() external view returns (address) {
        return _merchantContract;
    }

    /**
     * @notice View split wallets and rates
     */
    function viewSplitData()
        external
        view
        returns (address[] memory, uint16[] memory)
    {
        uint256 splitWalletsCount = _splitWallets.length;
        uint16[] memory splitRates = new uint16[](splitWalletsCount);
        for (uint256 i = 0; i < splitWalletsCount; i++) {
            splitRates[i] = _splitRates[_splitWallets[i]];
        }
        return (_splitWallets, splitRates);
    }

    /**
     * @dev receive payment from SlashCore Contract
     * @param receiveToken_: payment receive token
     * @param amount_: payment receive amount
     */
    function receivePayment(
        address receiveToken_,
        uint256 amount_,
        string memory, /* paymentId: PaymentId generated by the merchant when creating the payment URL */
        string memory /* optional: Optional parameter passed at the payment */
    ) external payable {
        IERC20Upgradeable(receiveToken_).universalTransferFromSenderToThis(
            amount_
        );

        uint256 splitCount = _splitWallets.length;
        uint32 totalRates;
        for (uint256 i = 0; i < splitCount; i++) {
            uint256 splittedAmount = (amount_ * _splitRates[_splitWallets[i]]) /
                RATE_PRECISION;
            IERC20Upgradeable(receiveToken_).universalTransfer(
                _splitWallets[i],
                splittedAmount
            );
            totalRates += _splitRates[_splitWallets[i]];

            emit PaymentSplitted(
                _splitWallets[i],
                receiveToken_,
                splittedAmount,
                _splitRates[_splitWallets[i]]
            );
        }
        // Sum of rates must be 100% (RATE_PRECISION)
        require(totalRates == RATE_PRECISION, "Invalid split configuration");
    }

    //to recieve ETH
    receive() external payable {}

    /**
     * @notice It allows the admin to recover wrong tokens sent to the contract
     * @param token_: the address of the token to withdraw
     * @param amount_: the number of tokens to withdraw
     * @dev This function is only callable by Slash owner.
     */
    function recoverWrongTokens(address token_, uint256 amount_)
        external
        onlyOwner
    {
        IERC20Upgradeable(token_).universalTransfer(_msgSender(), amount_);
    }
}
